"""Script ORM model.

This module defines the Script model for generated scripts with quality metrics
and lifecycle tracking. Uses scene-based scripts.
"""

import enum
import uuid
from typing import TYPE_CHECKING, Any

from sqlalchemy import Float, ForeignKey, Index, Integer, String, Text
from sqlalchemy.dialects.postgresql import ARRAY, JSON, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.models.base import Base, TimestampMixin, UUIDMixin
from app.models.scene import Scene, SceneScript

if TYPE_CHECKING:
    from app.models.channel import Channel
    from app.models.content_chunk import ContentChunk
    from app.models.topic import Topic
    from app.models.video import Video


class ScriptStatus(str, enum.Enum):
    """Script lifecycle status."""

    GENERATED = "generated"  # Generated, awaiting review
    REVIEWED = "reviewed"  # Reviewed by human
    APPROVED = "approved"  # Approved for production
    REJECTED = "rejected"  # Rejected, won't use
    PRODUCED = "produced"  # Video generated from this


class Script(Base, UUIDMixin, TimestampMixin):
    """Generated script with quality metrics.

    Stores scripts generated by the RAG system with quality scores,
    lifecycle status, and relationships to topics and channels.
    Uses scene-based structure for video generation.

    Attributes:
        channel_id: Foreign key to channels table
        topic_id: Foreign key to topics table
        script_text: Generated script content (full text)
        title_text: Title for video overlay
        scenes: Scene-based script structure (JSONB)
        estimated_duration: Estimated duration in seconds
        word_count: Word count
        style_score: Style consistency score (0-1)
        hook_score: Hook quality score (0-1)
        forbidden_words: List of forbidden words found
        quality_passed: Whether quality checks passed
        generation_model: LLM model used (e.g., "claude-3-5-sonnet")
        context_chunks_used: Number of RAG chunks used
        generation_metadata: Additional generation info (JSONB)
        status: Current script status
        channel: Associated channel
        topic: Associated topic
        content_chunks: ContentChunks created from this script
    """

    __tablename__ = "scripts"

    # Foreign Keys
    channel_id: Mapped[uuid.UUID] = mapped_column(
        ForeignKey("channels.id", ondelete="CASCADE"), nullable=False, index=True
    )
    topic_id: Mapped[uuid.UUID] = mapped_column(
        ForeignKey("topics.id", ondelete="CASCADE"), nullable=False, index=True
    )

    # Script Content
    script_text: Mapped[str] = mapped_column(Text, nullable=False)

    # Title for video overlay (상단 고정 제목)
    title_text: Mapped[str | None] = mapped_column(String(200))

    # Scene-based structure (new)
    # Stores JSON array: [{scene_type, text, keyword, visual_hint, ...}, ...]
    scenes: Mapped[list[dict[str, Any]] | None] = mapped_column(
        JSONB,
        nullable=True,
        comment="Scene-based script structure (list of Scene objects)",
    )

    # Metrics
    estimated_duration: Mapped[int] = mapped_column(Integer, nullable=False)  # seconds
    word_count: Mapped[int] = mapped_column(Integer, nullable=False)

    # Quality Scores
    style_score: Mapped[float] = mapped_column(Float, nullable=False, default=0.0)
    hook_score: Mapped[float] = mapped_column(Float, nullable=False, default=0.0)
    forbidden_words: Mapped[list[str]] = mapped_column(ARRAY(String), nullable=False, default=list)
    quality_passed: Mapped[bool] = mapped_column(nullable=False, default=False, index=True)

    # Generation Info
    generation_model: Mapped[str] = mapped_column(String(100), nullable=False)
    context_chunks_used: Mapped[int] = mapped_column(Integer, nullable=False, default=0)
    generation_metadata: Mapped[dict[str, Any]] = mapped_column(JSON, nullable=False, default=dict)

    # Status
    status: Mapped[ScriptStatus] = mapped_column(
        String(20),
        nullable=False,
        default=ScriptStatus.GENERATED,
        index=True,
    )

    # Relationships
    channel: Mapped["Channel"] = relationship("Channel", back_populates="scripts")
    topic: Mapped["Topic"] = relationship("Topic", back_populates="scripts")
    content_chunks: Mapped[list["ContentChunk"]] = relationship(
        "ContentChunk", back_populates="script", cascade="all, delete-orphan"
    )
    videos: Mapped[list["Video"]] = relationship(
        "Video", back_populates="script", cascade="all, delete-orphan"
    )

    # Composite Indexes
    __table_args__ = (
        Index("idx_script_channel_status", "channel_id", "status"),
        Index("idx_script_quality", "channel_id", "quality_passed"),
    )

    def __repr__(self) -> str:
        """String representation."""
        return f"<Script(id={self.id}, channel_id={self.channel_id}, status={self.status})>"

    @property
    def has_scenes(self) -> bool:
        """Check if script uses scene-based structure."""
        return self.scenes is not None and len(self.scenes) > 0

    def get_scene_script(self) -> SceneScript | None:
        """Parse scenes into SceneScript model.

        Returns:
            SceneScript if scenes exist, None otherwise
        """
        if not self.has_scenes or self.scenes is None:
            return None

        parsed_scenes = [Scene(**scene_data) for scene_data in self.scenes]
        return SceneScript(scenes=parsed_scenes, title_text=self.title_text)


__all__ = [
    "Script",
    "ScriptStatus",
]
